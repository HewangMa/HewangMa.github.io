<!DOCTYPE html>
<html lang="cn">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Summary-of-data-structure</title>
    <style>
        li.line {
            padding: 5px;
        }
    </style>
</head>

<body style="margin: 15% 15%;">
    <main>
        <div>
            <h1>计算机科学基础细节知识总结——数据结构</h1>
            <br>
            <p><b>作者： 禾旺</b></p>
            <b>目录：</b>
            <ul>
                <li class="line">第一章：概述</li>
                <li class="line">第二章：线性结构</li>
                <li class="line">第三章：树形结构</li>
                <li class="line">第四章：图</li>
                <li class="line">第五章：集合</li>
                <li class="line">第六章：查找</li>
                <li class="line">第七章：排序</li>
            </ul>
            <br>
            <br>
        </div>

        <div>
            <h2>第一章：概述</h2><br>
            <ul>
                <li class="line">
                    算法大题可以使用一般的解法就不要花太多时间，可以使用set、map、priority_queue、vector等数据结构，而考察具体的实现时，要写出具体操作（红黑树不可能，但是堆的实现（adjust）有可能）
                </li>
                <br>
                <br>
                <li class="line">时间复杂度通常指最坏情况下的时间复杂度，比如未优化的并查集高度为n</li>
                <li class="line">数组的逻辑不要想得太复杂，“三元组“题的方法是最普遍而简单的从0到n-1，要会设置一些结果变量如Dmin</li>
            </ul>
            <br>

            <h2>第二章：线性结构</h2><br>
            <ul>
                <li class="line">
                    将长度分别为m、n的两个有序表归并成一个有序表最少比较次数为min(m,n)，最多比较次数为m+n-1.</li>
                <li class="line">在双端队列的序列模拟中要严格模拟，不要记忆结论，栈也是；</li>
                <li class="line">在数组中找到所有两两之和等于x的数对方法：快速排序、从两端开始找（若a[i]+a[j]&lt;x,则i++，若a[i]+a[j]>x，则j--，否则输出a[i] a[j]
                    i++;j--;直到i>j）
                </li>
                <li class="line">栈和队列拥有相同的逻辑结构、不同的是运算</li>
                <li class="line">判断链表是否中心对称可以使用栈</li>
                <li class="line">
                    链式存储的队列如果不带头结点，则front和rear分别指向队首和队尾节点，如果带头结点，则front指向头节点，rear指向队尾节点；在删除时队头和队尾可能都需要修改（最后一个的时候要把rear=front）
                </li>
                <li class="line">队列的应用：页面替换算法、进程调度、缓冲区.
                    栈的应用：括号匹配、迷宫求解、递归、进制转换</li>
                <br><br>
                <li class="line">双栈：可以在O(1)时间内实现push、pop、min操作，主栈是普通栈，用来实现push和pop，辅助栈和主栈是同步的，每次push都将
                    stack_min[top++]=(x
                    &lt;min)?x:min; 每次pop时辅助栈也会pop，这样辅助栈栈顶永远是当前的最小值。</li>
                <li class="line">
                    KMP算法中要求的最关键的init即从-1、0开始的next数组，根据它产生相应的next（都+1）和nextval（从后往前，在init上将init[i]与自身相等的再往前迭代一次）数组。</li>
                <li class="line">循环链表的逆置也使用头插法</li>
                <li class="line">同一组不重复输入序列执行不同的入栈出栈操作，得到的结果也可能相同，因为初态终态并没有限制</li>
                <li class="line">循环队列“在队列末尾使用牺牲一个单元的方法判断队空队满“，队空条件为rear==front，队满为（rear+1）%n==front，rear指向的是队尾元素的下一个存储单位
                </li><br><br>
                <li class="line">如果线性表相关算法题的具体操作代码太长，则可以写一部分伪代码，节省答题空间</li>
                <li class="line">矩阵每行有序、每列有序的查找算法： </li>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li><span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> i = <span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>, j = n<span style="color: rgb(0, 92, 197); font-weight: 400;">-1</span>；</li><li><span style="color: rgb(215, 58, 73); font-weight: 400;">while</span> (<span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>) {</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (a[i][j] == x)<span style="color: rgb(215, 58, 73); font-weight: 400;">break</span>;</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (a[i][j] &gt; x)j--;</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">else</span> i++;</li><li>}</li></ol></pre>
                <li class="line">链表逆序：</li>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li>Void <span style="color: rgb(111, 66, 193); font-weight: 400;">reverese</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(listNode* L)</span>{	<span style="color: rgb(106, 115, 125); font-weight: 400;">//l指向头节点</span></li><li>    listNode* p=l-&gt;next;</li><li>    l-&gt;next=<span style="color: rgb(0, 92, 197); font-weight: 400;">NULL</span>;</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">while</span>(p){</li><li>	listNode* temp=p;</li><li>        p=p-&gt;next;</li><li>        temp-&gt;next=l-&gt;next;</li><li>        l-&gt;next=temp;</li><li>    }</li><li>}</li><li></li></ol></pre>
                <li class="line">有序链表求交集：</li>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li>listNode* <span style="color: rgb(111, 66, 193); font-weight: 400;">ins</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(listNode* A,listNode* B, listNode* C)</span>{</li><li>    listNode* a=A-&gt;next,*b=B-&gt;next,*c=C;</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">while</span>(a&amp;&amp;b){</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span>(a-&gt;data==b-&gt;data){</li><li>            listNode*p=new listNode(a-&gt;data);</li><li>            c-&gt;next=p;</li><li>            c=c-&gt;next;</li><li>        }</li><li>        Else <span style="color: rgb(111, 66, 193); font-weight: 400;">if</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(a-&gt;data&gt;b-&gt;data)</span>b=b-&gt;next;</li><li>        Else a=a-&gt;next;</li><li>    }</li><li>}</li><li></li></ol></pre>
                <li class="line">链表中也可以使用for：for (listNode*p=L;p!=NULL;p=p->next)//要使用这样比较规范的代码</li>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li>Dnode* <span style="color: rgb(111, 66, 193); font-weight: 400;">locate</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(Dnode* l, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> x)</span> {</li><li>    <span style="color: rgb(106, 115, 125); font-weight: 400;">//用于实现链表根据访问频率使元素向前移动</span></li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (Dnode* p = l-&gt;next;p != <span style="color: rgb(0, 92, 197); font-weight: 400;">NULL</span>;p = p-&gt;next) {</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (p-&gt;data == x) {</li><li>            p-&gt;fre++;<span style="color: rgb(106, 115, 125); font-weight: 400;">//频度加1</span></li><li>            Dnode* xpre = p-&gt;pre, * xnext = p-&gt;next;<span style="color: rgb(106, 115, 125); font-weight: 400;">//局部变量，函数结束即失效，不会占用内存</span></li><li>            xpre-&gt;next = xnext;</li><li>            xnext-&gt;pre = xpre;<span style="color: rgb(106, 115, 125); font-weight: 400;">//完成摘下</span></li><li>            Dnode* pos = l;</li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (;pos-&gt;fre &gt; p-&gt;fre;pos = pos-&gt;next);<span style="color: rgb(106, 115, 125); font-weight: 400;">//找到第一个fre小于等于p的节点，准备将插到前面</span></li><li>            Dnode* ppre = pos-&gt;pre;</li><li>            p-&gt;next = pos;</li><li>            pos-&gt;pre = p;</li><li>            ppre-&gt;next = p;</li><li>            p-&gt;pre = ppre;<span style="color: rgb(106, 115, 125); font-weight: 400;">//双向链表的头插法</span></li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">return</span> p;</li><li>	}</li><li>    }</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">return</span> <span style="color: rgb(0, 92, 197); font-weight: 400;">NULL</span>;</li><li>}</li><li></li></ol></pre>
                <li class="line">判断链表是否有环：</li>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li>listNode* <span style="color: rgb(111, 66, 193); font-weight: 400;">loop</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(listNode* l)</span>{</li><li>    listNode*p=l;</li><li>    <span style="color: rgb(227, 98, 9); font-weight: 400;">unordered_set</span>&lt;listNode*&gt;se;</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">while</span>(<span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>){</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span>(se.count(p))<span style="color: rgb(106, 115, 125); font-weight: 400;">//如果se里已经有p</span></li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">return</span> p;</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">else</span>{</li><li>            se.push(p);</li><li>            p=p-&gt;next;</li><li>        }</li><li>    }</li><li>}</li><li></li></ol></pre>
                <li class="line">TopK：</li>
                <img src="p1.jpg" alt="TopK：" style="display: block; height: 280px; margin: 0 auto;">
                <li class="line">单调栈在nums2中寻找nums1中每个元素的下一个最大数</li>
                <img src="p2.png" alt="下一个最大数" style="display: block; height: 280px; margin: 0 auto;">
            </ul>
            <br>

            <h2>第三章：树形结构</h2><br>
            <ul>
                <li class="line">把二叉树所有节点（包括NULL和空位）都保存（规范顺序存储，正逆向都要注意空位要补全）</li>
                <li class="line">按层次从上到下、同一层从左到右的顺序存储在数组中，不保存NULL节点（不规范的顺序存储）</li>
                <li class="line">顺序存储的第i个节点的祖先是ceiling(m/2)-1（编号从0开始，如果从1开始就另外推算推算）,依此可以寻找其各代祖先</li>
                <li class="line">二叉树是逻辑结构，但线索二叉树是加上线索之后的二叉链表结构，属于物理结构</li>
                <li class="line">非空二叉树（空二叉树不成立！）的叶子节点数目等于度为二的节点个数加一（n0=n2+1）</li>
                <li class="line">卡特兰数：C(n,2n)/(n+1);</li><br><br>
                <li class="line">路径长度计算需要计算所有的叶子节点; <br>
                    树的路径长度是根到每个节点的路径长度之和; <br>
                    哈夫曼树带权路径长度是所有叶节点的带权路径之和; <br>
                    树的度是所有节点度的最大值;
                </li>
                <li class="line">给定权值总数为n的哈夫曼树节点总数为2n-1</li>
                <li class="line">哈夫曼树中如果有负权值则叶子节点到根节点的路径序列不一定有序</li>
                <li class="line">哈夫曼编码要小心0和1的走向、只有叶节点可以编码</li><br><br>
                <li class="line">判断树是否镜像：
                    Ismirror（a,b） 判断两棵树是否镜像（递归比较ismirror(a->left,b->right)&& ismirror(a->right,b->left)），再用mirror（root）
                </li>
                <li class="line">树的算法题一定要会非递归的后序遍历，找叶子节点和计算深度之用</li>
                <li class="line">一般情况下，先思考使用递归的先序、后序遍历算法；</li>
                <li class="line">在孩子兄弟表示法存储的树中，主要的“左右孩子”是“孩子节点”和“兄弟节点”，故在递归的时候可以把这两个当作二叉树的左右孩子来写代码</li>
                <li class="line">将二叉链表中的二叉树放进数组里：</li>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li>Void <span style="color: rgb(111, 66, 193); font-weight: 400;">trans</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(TreeNode* root, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> b[], <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> k)</span>{</li><li>    If(root){</li><li>        b[k]=root-&gt;data;</li><li>        trans(root-&gt;left,b,<span style="color: rgb(0, 92, 197); font-weight: 400;">2</span>*k+<span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>);</li><li>        trans(root-&gt;right,b,<span style="color: rgb(0, 92, 197); font-weight: 400;">2</span>*k+<span style="color: rgb(0, 92, 197); font-weight: 400;">2</span>);</li><li>    }</li><li>}</li><li></li></ol></pre>
                <br><br>
                <li class="line">使用<br>buildTreeNode_from_to( int pre[], int l_pre, int r_pre, int in[], int l_in, int
                    r_in)<br>函数对“由中序、先序遍历序列构造二叉树”等问题求解</li>
                <li class="line">判断一个数是否是完全二叉树：将所有节点入队（包括空节点），遍历时如果碰到空节点，那么这时队列需要为空，否则不是完全二叉树</li>
                <li class="line">后序遍历的递归栈存了正在访问的节点的所有祖先，如果要逐个访问其祖先，则可以使用数组栈，并用下标访问；</li>
                <br><br>
                <li class="line">后序线索树的后序遍历仍然需要栈的支持</li>
                <li class="line">树的算法题的时间复杂度一般都是O(n),因为即使是递归遍历也是每个节点遍历一次</li><br><br>
                <li class="line">二叉树的遍历和应用</li>
                <b>先序遍历非递归版本</b>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li>Void <span style="color: rgb(111, 66, 193); font-weight: 400;">preOrder</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(TreeNode* root)</span>{</li><li>    If ( !root ) <span style="color: rgb(215, 58, 73); font-weight: 400;">return</span>;</li><li>    TreeNode* p=root;</li><li>    Stack&lt;TreeNode*&gt; st;</li><li>    While( !st.empty() || p ){</li><li>        If( p ){</li><li>            Visit(p);</li><li>            St.push(p);</li><li>            P=p-&gt;left;</li><li>        }</li><li>        Else{</li><li>            P=st.top();</li><li>            St.pop();</li><li>            P=p-&gt;right;</li><li>        }<span style="color: rgb(106, 115, 125); font-weight: 400;">//else</span></li><li>    }<span style="color: rgb(106, 115, 125); font-weight: 400;">//while</span></li><li>}</li><li></li></ol></pre>
                <b>中序遍历非递归版本</b>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li>Void <span style="color: rgb(111, 66, 193); font-weight: 400;">inOrder</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(TreeNode* root)</span>{</li><li>    If ( !root ) <span style="color: rgb(215, 58, 73); font-weight: 400;">return</span>;</li><li>    TreeNode* p=root;</li><li>    Stack&lt;TreeNode*&gt; st;</li><li>    While( !st.empty() || p ){</li><li>        If( p ){</li><li>            St.push(p);</li><li>            P=p-&gt;left;</li><li>        }</li><li>        Else{</li><li>            P=st.top();</li><li>            St.pop();</li><li>            Visit(p);</li><li>            P=p-&gt;right;</li><li>        }<span style="color: rgb(106, 115, 125); font-weight: 400;">//else</span></li><li>    }<span style="color: rgb(106, 115, 125); font-weight: 400;">//while</span></li><li>}</li></ol></pre>
                <b>后序遍历非递归版本</b>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li>Void <span style="color: rgb(111, 66, 193); font-weight: 400;">inOrder</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(TreeNode* root)</span>{</li><li>    If ( !root ) <span style="color: rgb(215, 58, 73); font-weight: 400;">return</span>;</li><li>    TreeNode* p=root , * r=<span style="color: rgb(0, 92, 197); font-weight: 400;">NULL</span>;</li><li>    Stack&lt;TreeNode*&gt; st;</li><li>    While( !st.empty() || p ){</li><li>        If( p ){</li><li>            St.push(p);</li><li>            P=p-&gt;left;</li><li>        }</li><li>        Else{</li><li>            P=st.top();</li><li>            If ( p-&gt;right &amp;&amp; p-&gt;right!=r ){</li><li>                P=p-&gt;right;</li><li>            }<span style="color: rgb(106, 115, 125); font-weight: 400;">//如果右边有 且没有被访问过 则转向右边</span></li><li>            Else {</li><li>                St.pop();</li><li>                Visit(p);</li><li>                R=p;</li><li>                P=<span style="color: rgb(0, 92, 197); font-weight: 400;">NULL</span>;</li><li>            }<span style="color: rgb(106, 115, 125); font-weight: 400;">//否则访问p，四步缺一不可</span></li><li>        }<span style="color: rgb(106, 115, 125); font-weight: 400;">//else</span></li><li>    }<span style="color: rgb(106, 115, 125); font-weight: 400;">//while</span></li><li>}</li></ol></pre>
                <li class="line">应用：求二叉树深度：遍历过程中最大的栈深度即为二叉树深度
                    求两个节点层数最高的共同祖先，使用双栈记录二者各自的祖先。
                </li>
                <li class="line">层序遍历带层数版代码</li>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li><span style="color: rgb(215, 58, 73); font-weight: 400;">void</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">levelOrderLev</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(TreeNode* root)</span> {</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (!root) <span style="color: rgb(215, 58, 73); font-weight: 400;">return</span>;</li><li>    <span style="color: rgb(227, 98, 9); font-weight: 400;">queue</span>&lt;<span style="color: rgb(227, 98, 9); font-weight: 400;">pair</span>&lt;TreeNode*,<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt;&gt; qu;</li><li>    TreeNode* p = root;</li><li>    qu.push(<span style="color: rgb(227, 98, 9); font-weight: 400;">make_pair</span>(p,<span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>));</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">while</span> (!qu.empty()) {</li><li>        p = qu.front().first;</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> lev = qu.front().second;</li><li>        qu.pop();</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (lev != qu.front().second || qu.empty()) {</li><li>            <span style="color: rgb(106, 115, 125); font-weight: 400;">//表明已经弹出当前层的最后一个节点</span></li><li>            visit1(p, lev);</li><li>        }</li><li>        Else <span style="color: rgb(111, 66, 193); font-weight: 400;">visit2</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(p,lev)</span>; </li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (p-&gt;left)qu.push(<span style="color: rgb(227, 98, 9); font-weight: 400;">make_pair</span>(p-&gt;left,lev+<span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>));</li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (p-&gt;right)qu.push(<span style="color: rgb(227, 98, 9); font-weight: 400;">make_pair</span>(p-&gt;right,lev+<span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>));</li><li>    }</li><li>}</li><li></li></ol></pre>
            </ul>
            <br>

            <h2>第四章：图</h2><br>
            <ul>
                <li class="line">
                    默认认为“有向图”是联通的，有向图邻接矩阵中，如果主对角线一下元素全为0，则其拓扑序列一定存在但不唯一（要会举例），如果主对角线以上元素全为1，主对角线以下元素全为0，则拓扑序列唯一;如果一个有向图存在有序拓扑排序序列，则其邻接矩阵一定是三角矩阵
                </li>
                <li class="line">有向图这种数据结构默认没有插入和删除操作</li>
                <li class="line">有向图边&lt;v,w>中，v表示弧尾，w表示弧头，箭头向右打</li>
                <li class="line">“一个数字的含义是什么？”可以为“路径的条数”而不是“存在路径”</li>
                <li class="line">图的应用题要把题目问的元素（比如每次选择的边）写清楚</li>
                <li class="line">使用邻接表存储无向完全图需要n(n-1)个边界点，而使用邻接多重表需要n(n-1)/2个；</li>
                <li class="line">强连通是针对有向图说的，连通是针对无向图说的，强连通分量是有向图的极大连通子图</li><br><br>
                <li class="line">AOV网只讨论拓扑排序，AOE网只讨论关键路径</li>
                <li class="line">计算关键路径时需要仔细十以内加减法的正确性</li>
                <li class="line">并不是任意顶点和任意边的组合都是子图，因为这样的组合可能不是图</li>
                <li class="line">连通分量就是极大连通子图，强连通分量就是极大强连通（任意两个顶点之间都有互相到达的路径）子图</li>
                <li class="line">极小连通子图是连通无向图的生成树。极小和极大是在满足连通的情况下，针对边的数目而言的。</li>
                <li class="line">有向图顶点的度是入度和出度的和</li>
                <li class="line">回路对应于路径，简单回路对应于简单路径</li><br><br>
                <li class="line">十字链表（有向图，弧用arc）：<br>
                    顶点节点：data、firstin、firstout <br>
                    弧节点：head_link, head, info, tail, tail_link（与下面的其实是类似的）</li>
                <li class="line">邻接多重表（无向图，边用edge）：<br>
                    顶点节点：data、firstedge<br>
                    边节点：v1_link, v1,info, v2, v2_link</li>
                <li class="line">判断一个无向图是不是一棵树：一次深度遍历，如果访问的顶点数是n且边数为 2(n-1)，则这是一颗树：</li>
                <img src="p3.png" alt="判断一个无向图是不是一棵树" style="display: block; height: 280px; margin: 0 auto;">
                <li class="line">在DFS中使用参数返回如“can_reach”、“length”等</li>
                <li class="line">使用DFS：判断一个有向图是否存在这样的顶点，该顶点到其他所有顶点都有路径的方法：从每个顶点出发都使用一次DFS，若能遍历所有顶点，则该点符合条件，时间复杂度O(n^2)
                </li>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li>For(<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> i=<span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>;i&lt;G.n;i++){</li><li>    Int N=<span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>;</li><li>    DFS(G,I,visited,N);<span style="color: rgb(106, 115, 125); font-weight: 400;">//注意参数设置</span></li><li>    If(N==G.n)<span style="color: rgb(215, 58, 73); font-weight: 400;">return</span> <span style="color: rgb(0, 92, 197); font-weight: 400;">true</span>;</li><li>}</li><li></li></ol></pre>
                <li class="line">
                    DFS压栈的顺序是拓扑序列，那么退栈的顺序就是逆拓扑序列，在DFS的末尾（如果放在开头，则结论相反，这是由递归的特性决定的）加上“time++;finishtime[v]=time”则可以计算所有顶点递归遍历时结束的时间，结束时间最晚的就是拓扑排序的开始节点，而最早结束的是拓扑序列中的最后节点
                </li>
                <li class="line">Prim算法的时间复杂度：使用邻接矩阵O(V^2) ，使用邻接表为O(E*logV);<br>
                    Kruskal算法的时间复杂度是O(ElogV),一般不会使用邻接矩阵计算Kruskal，因为寻找边集不方便
                </li>
                <li class="line">邻接表表示的拓扑排序的时间复杂度是O(V+E)（要想象消边的过程），邻接矩阵表示的是O(V^2)</li>
                <li class="line">在邻接矩阵的复杂度判断中不考虑E</li>
                <li class="line">
                    Prim算法每次选择离MST中任意节点最近的下一条边，而Dijkstra算法每次选择离源点最近的边；进而Dijkstra算法可以产生生成树，但不一定是最小生成树，至少起点所连的边（如果值相同）必须全部加入
                </li>
                <li class="line">Floyd算法求每对不同顶点之间最短路径时，允许弧上的权值为负，但不能有包含负权值边的回路</li>
                <li class="line">
                    Kruskal算法要用到并查集（在选边之前先判断两个顶点是否属于同一个集合，如果是则不加入，如果不是，则加入并且把集合合并），无向图的连通性判断要用到并查集（遍历图的每个边，每次把边两端的顶点所在的集合合并，直到遍历完所有的边，如果只剩下一个集合则说明无向图是连通的，否则不连通）
                </li><br><br>
                <li class="line">图的遍历算法</li>
                <b>广度优先遍历:</b>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li><span style="color: rgb(215, 58, 73); font-weight: 400;">void</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">BFS</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(Gragh G, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> v)</span> {</li><li>    <span style="color: rgb(227, 98, 9); font-weight: 400;">queue</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt; qu;</li><li>    qu.push(v);</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">while</span> (!qu.empty()) {</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> p = qu.front();</li><li>        qu.pop();</li><li>        visit(p) ; </li><li>        visited[p] = <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> x = firstNeighber(G, p) ; x &lt; n ; x = nextNeighber(G, p, x)) {</li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (!visited[x]) qu.push(x);</li><li>        }<span style="color: rgb(106, 115, 125); font-weight: 400;">//把所有的邻居都加进来</span></li><li>    }</li><li>}</li><li><span style="color: rgb(215, 58, 73); font-weight: 400;">void</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">bTraverse</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(Gragh G)</span> {</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> n = G.vexnum();</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">static</span> <span style="color: rgb(227, 98, 9); font-weight: 400;">vector</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt; visited;</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> i = <span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>;i &lt; n;i++) visited.push(<span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>);</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> v = <span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>;v &lt; n;v++)</li><li>    <span style="color: rgb(106, 115, 125); font-weight: 400;">//对于每个连通分量</span></li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (!visited[v])BFS(G, v);</li><li>}</li></ol></pre>
                <li class="line">应用：广度遍历求无权值单源最短路径</li>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li><span style="color: rgb(215, 58, 73); font-weight: 400;">void</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">BFS</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(Gragh G, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> v)</span> {</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> n=G.vexnum();</li><li>    <span style="color: rgb(227, 98, 9); font-weight: 400;">vector</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt;d;</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> i=<span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>;i&lt;n;i++) d.push(INT_MAX);</li><li>    d[v]=<span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>;</li><li>    <span style="color: rgb(227, 98, 9); font-weight: 400;">queue</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt; qu;</li><li>    qu.push(v);</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">while</span> (!qu.empty()) {</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> p = qu.front();</li><li>        qu.pop();</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> x = firstNeighber(G, p) ; x &lt; n ; x = nextNeighber(G, p, x)) {</li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (!visited[x]){</li><li>                qu.push(x);visited[x]=<span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;</li><li>                d[x]=d[p]+<span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;<span style="color: rgb(106, 115, 125); font-weight: 400;">//到x的距离是当前点距离加1，这就是最短的路径，因为单权值单源最短路径问题中，广度遍历时同一层的结果相同，都是最短的</span></li><li>            }</li><li>        }<span style="color: rgb(106, 115, 125); font-weight: 400;">//把所有的邻居都加进来</span></li><li>    }</li><li>}</li></ol></pre>
                <b>深度优先遍历:</b>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li><span style="color: rgb(215, 58, 73); font-weight: 400;">void</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">DFS</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(Gragh G, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> v)</span> {<span style="color: rgb(106, 115, 125); font-weight: 400;">//递归版</span></li><li>    visit(v);</li><li>    visited[v]=<span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> x = firstNeighber(G, p) ; x &gt;=<span style="color: rgb(0, 92, 197); font-weight: 400;">0</span> ; x = nextNeighber(G, p, x)) {</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span>( !visited[x] ) DFS(G,x);</li><li>    }<span style="color: rgb(106, 115, 125); font-weight: 400;">//对所有的邻居都深度遍历一次</span></li><li>}</li><li>Void <span style="color: rgb(111, 66, 193); font-weight: 400;">DFS</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(Gragh G,<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> v)</span>{<span style="color: rgb(106, 115, 125); font-weight: 400;">//非递归版</span></li><li>    <span style="color: rgb(106, 115, 125); font-weight: 400;">//思路是使用栈记录接下来可能要访问的顶点</span></li><li>    <span style="color: rgb(106, 115, 125); font-weight: 400;">//同时用数组标记那些已经入栈过，实际上入栈也就代表访问过</span></li><li>    Stack&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt; st;</li><li>    St.push(v);</li><li>    Visited[v]=<span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;</li><li>    While( !st.empty() ){</li><li>        Int p=st.top(); st.pop();</li><li>        Visit(p);</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> x = firstNeighber(G, p) ; x &gt;=<span style="color: rgb(0, 92, 197); font-weight: 400;">0</span> ; x = nextNeighber(G, p, x)) {</li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span>( !visited[x] ){</li><li>                st.push(x); visited[x]=<span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;</li><li>            }</li><li>        }</li><li>    }</li><li>}</li><li><span style="color: rgb(215, 58, 73); font-weight: 400;">void</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">bTraverse</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(Gragh G)</span> {</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> n = G.vexnum();</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">static</span> <span style="color: rgb(227, 98, 9); font-weight: 400;">vector</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt; visited;</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> i = <span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>;i &lt; n;i++) visited.push(<span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>);</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> v = <span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>;v &lt; n;v++)</li><li>        <span style="color: rgb(106, 115, 125); font-weight: 400;">//对于每个连通分量</span></li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (!visited[v])DFS(G, v);</li><li>}</li></ol></pre>
            </ul>
            <br>

            <h2>第五章：集合</h2><br>
            <ul>
                <li class="line">没有太多考察内容，要理解并查集的应用场景：Kruskal、无向图连通性的判断（逐个加边法）</li>
            </ul>
            <br>

            <h2>第六章：查找</h2><br>
            <ul>
                <li class="line">查找失败的长度需要计算最后寻找空位的那一次；</li>
                <li class="line">
                    若n表示顺序表长度，则顺序查找成功的ASL=a1=1/2(n+1)；查找失败的ASL=a2=n+1；如果两者概率相等，则总ASL=(a1+a2)/2，注意区分概率和长度，举例时注意严格根据例子来算与n的关系
                </li>
                <li class="line">在二叉排序树中计算查找长度的关键是画出二叉排序树</li>
                <li class="line">二叉排序树是增加了排序性质的二叉树，因此算法题仍然是基于二叉树的递归特点，只是需要多考虑排序性质而已。</li>
                <li class="line">注意二叉排序树的概念：根节点要小于右子树中所有节点，而不仅是要小于右子树的根（容易混淆）</li>
                <br><br>
                <li class="line">nh表示高度为h的平衡二叉树含有的最少节点数，则n1=1；n2=2；nh=(nh-1)+(nh-2)+1</li>
                <li class="line">在平衡树中删除一个顶点再加入同一个顶点，得到的树可能相同，参考“1、2、3“，在开始重要善于直接写出实例</li>
                <li class="line">注意平衡子树指的是平衡因子（h左-h右）小于等于1的子树（只差1仍是平衡的）</li><br><br>
                <li class="line">红黑树的性质：<br>
                    每个节点或红或黑 <br>
                    根节点是黑色的 <br>
                    叶节点（虚构的外部节点、NULL节点）都是黑色的，这说明终端节点（最底层的非叶节点）可红可黑 <br>
                    不存在相邻的红节点（任意红节点的父节点和孩子节点都是黑色的） <br>
                    对于每个节点，从该节点到任意叶节点的简单路径上所含的黑结点数目相同
                </li>
                <li class="line">红黑树的推论： <br>
                    从根节点到叶节点最长路径不大于最短路径的2倍 <br>
                    红黑树将AVL树的“高度平衡”，降低到“任意节点左右子树的高度相差不超过两倍”
                </li>
                <li class="line">红黑树和AVL数的插入、查找、删除的平均复杂度都是O(log n)，但红黑树的统计性能更好</li><br><br>
                <li class="line">
                    B树的插入总体是在最下层堆积，堆不下了才往上溢；而删除（只会删除终端节点，要删除非终端节点时先用相邻的终端节点替代他然后在删除该终端节点）是在最下层沉淀，只要能沉下来就会把上面的往下沉，熟练掌握。
                </li>
                <li class="line">B树的所有终端节点的高度是一致的。</li>
                <li class="line">具有n个关键字的B树应该有n+1个叶节点（即查找失败的外部节点）</li><br><br>
                <li class="line">B+树比B树更加适用于实际应用中的文件索引和数据库索引</li>
                <li class="line">B+树每个索引项只包含对应子树的最大关键字和指向该子树的指针</li>
                <li class="line">二叉查找树的画法要注意使用统一的方式：一般是向下取整</li>
                <li class="line">注意提到二分查找树的时候，一般认为关键字是有序的，而是否随机分布决定了平均查找长度能否达到log(n)</li><br><br>
                <li class="line">散列表楚除留余数法选用的p一般是小于等于m的最大质数（留下一部分用来处理冲突）</li>
                <li class="line">注意双散列法的第二个散列函数计算的是地址增量，Hi=(H(key)+i*Hash2(key))%m, i表示冲突次数</li>
                <li class="line">散列表查找成功的平均查找长度与装填因子直接相关，与表长无关</li>
                <li class="line">Hash聚集：非同义词争夺一个地址的现象；一般是线性探测产生的</li>
                <li class="line">Hash冲突：同义词争夺一个地址的现象；都会产生</li>
                <li class="line">二分查找</li>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li><span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">bsearch</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(<span style="color: rgb(227, 98, 9); font-weight: 400;">vector</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt;a, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> low, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> high, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> x)</span>{</li><li>    Int mid=low;</li><li>    While(low&lt;=high){</li><li>        Mid=low+(high-low)&gt;&gt;<span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;</li><li>        If(a[mid]==x)<span style="color: rgb(215, 58, 73); font-weight: 400;">break</span>;</li><li>        Else <span style="color: rgb(111, 66, 193); font-weight: 400;">if</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(a[mid]&gt;x)</span> High=mid<span style="color: rgb(0, 92, 197); font-weight: 400;">-1</span>;</li><li>        Else Low=mid+<span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;</li><li>    }</li><li>    Retrun low;<span style="color: rgb(106, 115, 125); font-weight: 400;">//返回的是插入位置</span></li><li>}</li></ol></pre>
            </ul>
            <br>

            <h2>第七章：排序</h2><br>
            <ul>
                <li class="line">快速排序每次划分后先处理短分区可以减小递归深度但不能减少递归次数；如果分区均衡，可以减少递归次数和运行时间。</li>
                <li class="line">
                    Partirion函数如果没有递归z就没有递归深度，可以使用栈或者队列来实现快速排序的非递归算法，只要用栈或队列记录每次划分的两个端点，在下一次处理时取出即可，他们产生的顺序会不同</li>
                <li class="line">要牢记的是quicksort和heapsort！！</li><br><br>
                <li class="line">荷兰国旗问题：即三数排序</li>
                <img src="p4.jpg" alt="荷兰国旗问题" style="display: block; height: 280px; margin: 0 auto;">
                <li class="line">构建n个记录的初始堆，其时间复杂度为O(n)（比较不直观，需要死记）</li>
                <li class="line">堆排序属于选择排序，其思想为“每次从堆中选择最大的”，而堆的作用就是logn时间内找到最大的元素</li>
                <li class="line">直接选择排序是不稳定的，基数排序（因为分配和回收处理不会影响同义词）和归并排序是稳定的</li>
                <li class="line">归并排序需要会把两个数组并排放，依次比较，计算比较次数</li>
                <img src="p5.png" alt="归并排序" style="display: block; height: 280px; margin: 0 auto;"><br><br>
                <li class="line">关于分块排序：要弄清楚块与块之间的关系是怎样的，“仅块内有序”可以使用归并方式思考，二题中给出的是“块内无序，块间有序”，只需要块内排序即可。</li>
                <img src="p6.png" alt="" style="display: block; height: 60px; margin: 0 auto;"><br><br>
                <li class="line">要掌握的排序算法</li>
                <b>简单插入排序</b>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li><span style="color: rgb(215, 58, 73); font-weight: 400;">void</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">insertSort</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(<span style="color: rgb(227, 98, 9); font-weight: 400;">vector</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt;&amp; a)</span> {</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> n = a.size();</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> i = <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;i &lt; n;i++) {</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (a[i] &lt; a[i - <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>]) {</li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> temp = a[i];</li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> j = i - <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;</li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (;a[j] &gt; temp;j--)a[j + <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>] = a[j];</li><li>            a[j + <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>] = temp;</li><li>        }</li><li>    }<span style="color: rgb(106, 115, 125); font-weight: 400;">//for</span></li><li>}</li></ol></pre>
                <b>希尔排序</b>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li><span style="color: rgb(215, 58, 73); font-weight: 400;">void</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">shellSort</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(<span style="color: rgb(227, 98, 9); font-weight: 400;">vector</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt;&amp; a)</span> {</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> n = a.size();</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> dis = n / <span style="color: rgb(0, 92, 197); font-weight: 400;">2</span>;dis &gt;= <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;dis /= <span style="color: rgb(0, 92, 197); font-weight: 400;">2</span>) {</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> i = dis;i &lt; n;i++) {</li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (a[i] &lt; a[i - dis]) {</li><li>                <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> temp = a[i];</li><li>                <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> j = i - dis;</li><li>                <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (;a[j] &gt; temp &amp;&amp; j &gt; <span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>;j -= dis) a[j + dis] = a[j];</li><li>                a[j + dis] = temp;</li><li>            }</li><li>        }<span style="color: rgb(106, 115, 125); font-weight: 400;">//for</span></li><li>    }</li><li>}</li></ol></pre>
                <b>折半插入排序</b>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li><span style="color: rgb(215, 58, 73); font-weight: 400;">void</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">halfInsertSort</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(<span style="color: rgb(227, 98, 9); font-weight: 400;">vector</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt;&amp; a)</span> {</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> n = a.size();</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> i = <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;i &lt; n;i++) {</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (a[i] &lt; a[i - <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>]) {</li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> temp = a[i];</li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> low = <span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>, high = i;</li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> mid = <span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>;</li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">while</span> (low &lt;= high) {</li><li>                mid = (low + high) &gt;&gt; <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;</li><li>                <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (a[mid] &gt; temp) high = mid - <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;</li><li>                <span style="color: rgb(215, 58, 73); font-weight: 400;">else</span> low = mid + <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;</li><li>            }</li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> j = i - <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;</li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (;j &gt; high;j--)a[j + <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>] = a[j];</li><li>            a[j + <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>] = temp;</li><li>        }</li><li>    }</li><li>}</li></ol></pre>
                <b>简单选择排序</b>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li><span style="color: rgb(215, 58, 73); font-weight: 400;">void</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">selectSort</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(<span style="color: rgb(227, 98, 9); font-weight: 400;">vector</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt;&amp; a)</span> {</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> n = a.size();</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> i = <span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>;i &lt; n;i++) {</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> index = i;</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> j = i;j &lt; n;j++) {</li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (a[j] &lt; a[index])</li><li>            index = j;</li><li>        }</li><li>        swap(a[i], a[index]);</li><li>        <span style="color: rgb(106, 115, 125); font-weight: 400;">//在代码中能使用swap就不要使用temp；</span></li><li>    }</li><li>}</li></ol></pre>
                <b>冒泡排序</b>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li><span style="color: rgb(215, 58, 73); font-weight: 400;">void</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">bubbleSort</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(<span style="color: rgb(227, 98, 9); font-weight: 400;">vector</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt;&amp; a)</span> {</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> n = a.size();</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> i = <span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>;i &lt; n - <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;i++)</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> j = i + <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;j &lt; n;j++)</li><li>            <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (a[i] &gt; a[j])</li><li>    swap(a[i], a[j]);</li><li>}</li></ol></pre>
                <b>快速排序</b>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li><span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">partition</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(<span style="color: rgb(227, 98, 9); font-weight: 400;">vector</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt;&amp;a, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> low, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> high)</span> {</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> index = rand() % (high - low + <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>) + low;</li><li>    swap(a[low], a[index]);</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> pivot = a[low];</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">while</span> (low &lt; high) {</li><li>        <span style="color: rgb(106, 115, 125); font-weight: 400;">//选择low作pivot则从high开始变</span></li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">while</span> (low &lt; high &amp;&amp; a[high] &gt;= pivot) high--;</li><li>        a[low] = a[high];</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">while</span> (low &lt; high &amp;&amp; a[low] &lt;= pivot) low++;</li><li>        a[high] = a[low];</li><li>    }</li><li>    a[low] = pivot;</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">return</span> low;</li><li>}</li><li><span style="color: rgb(215, 58, 73); font-weight: 400;">void</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">quickSort</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(<span style="color: rgb(227, 98, 9); font-weight: 400;">vector</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt;&amp;a, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> begin, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> end)</span> {</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (begin &lt; end) {</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> pos = partition(a, begin, end);</li><li>        quickSort(a, begin, pos - <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>);</li><li>        quickSort(a, pos + <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>, end);</li><li>    }</li><li>}</li></ol></pre>
                <b>归并排序</b>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li><span style="color: rgb(227, 98, 9); font-weight: 400;">vector</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt;b(<span style="color: rgb(0, 92, 197); font-weight: 400;">1010</span>);</li><li><span style="color: rgb(215, 58, 73); font-weight: 400;">void</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">merge</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(<span style="color: rgb(227, 98, 9); font-weight: 400;">vector</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt;&amp; a, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> low, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> mid, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> high)</span> {</li><li>    <span style="color: rgb(106, 115, 125); font-weight: 400;">//将a中low..mid和mid..high有序的两段合并,并放回a</span></li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> i = low;i &lt;= high;i++)b[i] = a[i];</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> k = <span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>, i = <span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>, j = <span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>;</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (i = low, j = mid + <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>, k = i; i &lt;= mid &amp;&amp; j &lt;= high;k++) {</li><li>        a[k] = (b[i]&lt;=b[j]) ? (b[i++]) : (b[j++]);</li><li>    }<span style="color: rgb(106, 115, 125); font-weight: 400;">//这里必须是&lt;=才能保证稳定</span></li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">while</span> (i &lt;= mid)a[k++] = b[i++];</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">while</span> (j &lt;= high)a[k++] = b[j++];</li><li>}</li><li><span style="color: rgb(215, 58, 73); font-weight: 400;">void</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">mergeSort</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(<span style="color: rgb(227, 98, 9); font-weight: 400;">vector</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt;&amp;a, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> low, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> high)</span> {</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (low &lt; high) {</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> mid = (low + high) &gt;&gt; <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;</li><li>        mergeSort(a, low, mid);</li><li>        mergeSort(a, mid + <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>, high);</li><li>        merge(a, low, mid, high);</li><li>    }</li><li>}</li></ol></pre>
                <b>堆排序//这是具体实现，而要用堆解决问题的时候要使用priority_queue</b>
                <pre
                    style="font-family:monospace;color: rgb(36, 41, 46); background-color: rgb(255, 255, 255); font-weight: 400; "><ol style="padding-left: 3em;"><li><span style="color: rgb(215, 58, 73); font-weight: 400;">void</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">heapAdjust</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(<span style="color: rgb(227, 98, 9); font-weight: 400;">vector</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt;&amp; a, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> k, <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> n)</span> {</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> temp = a[k];</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> i = <span style="color: rgb(0, 92, 197); font-weight: 400;">2</span> * k + <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;i &lt; n;i = i * <span style="color: rgb(0, 92, 197); font-weight: 400;">2</span> + <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>) {</li><li>        <span style="color: rgb(106, 115, 125); font-weight: 400;">//注意从哪里开始编号</span></li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (i + <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span> &lt; n &amp;&amp; a[i] &lt; a[i + <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>]) i++;</li><li>        <span style="color: rgb(215, 58, 73); font-weight: 400;">if</span> (temp &gt;= a[i]) <span style="color: rgb(215, 58, 73); font-weight: 400;">break</span>;</li><li>        a[k] = a[i];</li><li>        k = i;<span style="color: rgb(106, 115, 125); font-weight: 400;">//更新最终位置</span></li><li>    }</li><li>    a[k] = temp;<span style="color: rgb(106, 115, 125); font-weight: 400;">//放到最终位置上</span></li><li>}</li><li><span style="color: rgb(215, 58, 73); font-weight: 400;">void</span> <span style="color: rgb(111, 66, 193); font-weight: 400;">heapSort</span><span style="color: rgb(36, 41, 46); font-weight: 400;">(<span style="color: rgb(227, 98, 9); font-weight: 400;">vector</span>&lt;<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span>&gt;&amp; a)</span> {</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> n = a.size();</li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> i = (n - <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>) / <span style="color: rgb(0, 92, 197); font-weight: 400;">2</span>;i &gt;= <span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>;i--)</li><li>        heapAdjust(a, i, n);<span style="color: rgb(106, 115, 125); font-weight: 400;">//建立初始大根堆，处理结果是升序。</span></li><li>    <span style="color: rgb(215, 58, 73); font-weight: 400;">for</span> (<span style="color: rgb(215, 58, 73); font-weight: 400;">int</span> i = n - <span style="color: rgb(0, 92, 197); font-weight: 400;">1</span>;i &gt; <span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>;i--) {</li><li>        swap(a[i], a[<span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>]);<span style="color: rgb(106, 115, 125); font-weight: 400;">//把最大值a[0]交换到后面去</span></li><li>        heapAdjust(a, <span style="color: rgb(0, 92, 197); font-weight: 400;">0</span>, i);</li><li>    }</li><li>}</li></ol></pre>
                <li class="line">基数排序<br>
                    要知道排序原理，注意先以低位为关键字。</li>
                <li class="line">置换选择排序<br>
                    需要知道这是外部排序在生成初始归并段时使用的算法，要回手动计算</li>
            </ul>
            <br>
            <br>
        </div>

        <div>
            <h2>后记</h2>
            <br>
            <p>对于细节的知识整理不成系统，但是在处理很多细节的问题时可以提供参考，希望可以给读者以启发和帮助。
            </p>
            <br>
            <br>
        </div>
    </main>
    <footer>
        <p>&copy; 2024 Hewang's Tech Blog</p>
    </footer>
</body>

</html>